C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE CDC
OBJECT MODULE PLACED IN .\Objects\CDC.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CDC.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Public) DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\CDC.lst) TABS(2) OBJECT(.\Objects\CDC.obj)

line level    source

   1          /********************************** (C) COPYRIGHT *******************************
   2          * File Name          : CDC.C
   3          * Author             : WCH
   4          * Version            : V1.0
   5          * Date               : 2017/03/01
   6          * Description        : CH554×öCDCÉè±¸×ª´®¿Ú£¬Ñ¡Ôñ´®¿Ú1
   7          *******************************************************************************/
   8          #include "CH554.H"
   9          #include "DEBUG.H"
  10          #include "GPIO.H"
  11          
  12          #include <stdio.h>
  13          #include <string.h>
  14          
  15          UINT8X  Ep0Buffer[DEFAULT_ENDP0_SIZE] _at_ 0x0000;                                 //¶Ëµã0 OUT&IN»º³åÇø£¬±
             -ØÐëÊÇÅ¼µØÖ·
  16          UINT8X  Ep1Buffer[8] _at_ 0x0040;                                                  //¶Ëµã1ÉÏ´«»º³åÇø
  17          UINT8X  Ep2Buffer[2*MAX_PACKET_SIZE] _at_ 0x0080;                                  //¶Ëµã2 IN & OUT»º³åÇø,
             -±ØÐëÊÇÅ¼µØÖ·
  18          
  19          UINT16 SetupLen;
  20          UINT8   SetupReq,Count,UsbConfig;
  21          PUINT8  pDescr;                                                                //USBÅäÖÃ±êÖ¾
  22          USB_SETUP_REQ   SetupReqBuf;                                                   //ÔÝ´æSetup°ü
  23          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)
  24          
  25          #define  SET_LINE_CODING                0X20            // Configures DTE rate, stop-bits, parity, and num
             -ber-of-character
  26          #define  GET_LINE_CODING                0X21            // This request allows the host to find out the cu
             -rrently configured line coding.
  27          #define  SET_CONTROL_LINE_STATE         0X22            // This request generates RS-232/V.24 style contro
             -l signals.
  28          
  29          
  30          /*Éè±¸ÃèÊö·û*/
  31          UINT8C DevDesc[] = {0x12,0x01,0x10,0x01,0x02,0x00,0x00,DEFAULT_ENDP0_SIZE,
  32                              0x86,0x1a,0x22,0x57,0x00,0x01,0x01,0x02,
  33                              0x03,0x01
  34                             };
  35          UINT8C CfgDesc[] = {
  36            0x09,0x02,0x43,0x00,0x02,0x01,0x00,0xa0,0x32,             //ÅäÖÃÃèÊö·û£¨Á½¸ö½Ó¿Ú£©
  37            //ÒÔÏÂÎª½Ó¿Ú0£¨CDC½Ó¿Ú£©ÃèÊö·û
  38            0x09,0x04,0x00,0x00,0x01,0x02,0x02,0x01,0x00,             //CDC½Ó¿ÚÃèÊö·û(Ò»¸ö¶Ëµã)
  39            //ÒÔÏÂÎª¹¦ÄÜÃèÊö·û
  40            0x05,0x24,0x00,0x10,0x01,                                 //¹¦ÄÜÃèÊö·û(Í·)
  41            0x05,0x24,0x01,0x00,0x00,                                 //¹ÜÀíÃèÊö·û(Ã»ÓÐÊý¾ÝÀà½Ó¿Ú) 03 01
  42            0x04,0x24,0x02,0x02,                                      //Ö§³ÖSet_Line_Coding¡¢Set_Control_Line_State¡¢
             -Get_Line_Coding¡¢Serial_State
  43            0x05,0x24,0x06,0x00,0x01,                                 //±àºÅÎª0µÄCDC½Ó¿Ú;±àºÅ1µÄÊý¾ÝÀà½Ó¿Ú
  44            0x07,0x05,0x81,0x03,0x08,0x00,0xFF,                       //ÖÐ¶ÏÉÏ´«¶ËµãÃèÊö·û
  45            //ÒÔÏÂÎª½Ó¿Ú1£¨Êý¾Ý½Ó¿Ú£©ÃèÊö·û
  46            0x09,0x04,0x01,0x00,0x02,0x0a,0x00,0x00,0x00,             //Êý¾Ý½Ó¿ÚÃèÊö·û
  47            0x07,0x05,0x02,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û
  48            0x07,0x05,0x82,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 2   

  49          };
  50          /*×Ö·û´®ÃèÊö·û*/
  51          unsigned char  code LangDes[]= {0x04,0x03,0x09,0x04};          //ÓïÑÔÃèÊö·û
  52          unsigned char  code SerDes[]= {                                //ÐòÁÐºÅ×Ö·û´®ÃèÊö·û
  53            0x14,0x03,
  54            0x32,0x00,0x30,0x00,0x31,0x00,0x37,0x00,0x2D,0x00,
  55            0x32,0x00,0x2D,0x00,
  56            0x32,0x00,0x35,0x00
  57          };
  58          unsigned char  code Prod_Des[]= {                               //²úÆ·×Ö·û´®ÃèÊö·û
  59            0x14,0x03,
  60            0x43,0x00,0x48,0x00,0x35,0x00,0x35,0x00,0x34,0x00,0x5F,0x00,
  61            0x43,0x00,0x44,0x00,0x43,0x00,
  62          };
  63          unsigned char  code Manuf_Des[]= {
  64            0x0A,0x03,
  65            0x5F,0x6c,0xCF,0x82,0x81,0x6c,0x52,0x60,
  66          };
  67          
  68          //cdc²ÎÊý
  69          UINT8X LineCoding[7]= {0x00,0xe1,0x00,0x00,0x00,0x00,0x08};  //³õÊ¼»¯²¨ÌØÂÊÎª57600£¬1Í£Ö¹Î»£¬ÎÞÐ£Ñé£¬8Êý¾Ý
             -Î»¡£
  70          
  71          #define UART_REV_LEN  64                 //´®¿Ú½ÓÊÕ»º³åÇø´óÐ¡
  72          UINT8I Receive_Uart_Buf[UART_REV_LEN];   //´®¿Ú½ÓÊÕ»º³åÇø
  73          volatile UINT8I Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÐ´ÈëÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
  74          volatile UINT8I Uart_Output_Point = 0;  //Ñ­»·»º³åÇøÈ¡³öÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
  75          volatile UINT8I UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
  76          
  77          
  78          volatile UINT8I USBByteCount = 0;      //´ú±íUSB¶Ëµã½ÓÊÕµ½µÄÊý¾Ý
  79          volatile UINT8I USBBufOutPoint = 0;    //È¡Êý¾ÝÖ¸Õë
  80          
  81          volatile UINT8I UpPoint2_Busy  = 0;   //ÉÏ´«¶ËµãÊÇ·ñÃ¦±êÖ¾
  82          
  83          
  84          /*******************************************************************************
  85          * Function Name  : USBDeviceCfg()
  86          * Description    : USBÉè±¸Ä£Ê½ÅäÖÃ
  87          * Input          : None
  88          * Output         : None
  89          * Return         : None
  90          *******************************************************************************/
  91          void USBDeviceCfg() {
  92   1        USB_CTRL = 0x00;                                                           //Çå¿ÕUSB¿ØÖÆ¼Ä´æÆ÷
  93   1        USB_CTRL &= ~bUC_HOST_MODE;                                                //¸ÃÎ»ÎªÑ¡ÔñÉè±¸Ä£Ê½
  94   1        USB_CTRL |=  bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                    //USBÉè±¸ºÍÄÚ²¿ÉÏÀ­Ê¹ÄÜ,ÔÚÖÐ¶Ï
             -ÆÚ¼äÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶¯·µ»ØNAK
  95   1        USB_DEV_AD = 0x00;                                                         //Éè±¸µØÖ·³õÊ¼»¯
  96   1      //     USB_CTRL |= bUC_LOW_SPEED;
  97   1      //     UDEV_CTRL |= bUD_LOW_SPEED;                                                //Ñ¡ÔñµÍËÙ1.5MÄ£Ê½
  98   1        USB_CTRL &= ~bUC_LOW_SPEED;
  99   1        UDEV_CTRL &= ~bUD_LOW_SPEED;                                             //Ñ¡ÔñÈ«ËÙ12MÄ£Ê½£¬Ä¬ÈÏ·½Ê½
 100   1        UDEV_CTRL = bUD_PD_DIS;  // ½ûÖ¹DP/DMÏÂÀ­µç×è
 101   1        UDEV_CTRL |= bUD_PORT_EN;                                                  //Ê¹ÄÜÎïÀí¶Ë¿Ú
 102   1      }
 103          /*******************************************************************************
 104          * Function Name  : USBDeviceIntCfg()
 105          * Description    : USBÉè±¸Ä£Ê½ÖÐ¶Ï³õÊ¼»¯
 106          * Input          : None
 107          * Output         : None
 108          * Return         : None
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 3   

 109          *******************************************************************************/
 110          void USBDeviceIntCfg() {
 111   1        USB_INT_EN |= bUIE_SUSPEND;                                               //Ê¹ÄÜÉè±¸¹ÒÆðÖÐ¶Ï
 112   1        USB_INT_EN |= bUIE_TRANSFER;                                              //Ê¹ÄÜUSB´«ÊäÍê³ÉÖÐ¶Ï
 113   1        USB_INT_EN |= bUIE_BUS_RST;                                               //Ê¹ÄÜÉè±¸Ä£Ê½USB×ÜÏß¸´Î»ÖÐ¶Ï
 114   1        USB_INT_FG |= 0x1F;                                                       //ÇåÖÐ¶Ï±êÖ¾
 115   1        IE_USB = 1;                                                               //Ê¹ÄÜUSBÖÐ¶Ï
 116   1        EA = 1;                                                                   //ÔÊÐíµ¥Æ¬»úÖÐ¶Ï
 117   1      }
 118          /*******************************************************************************
 119          * Function Name  : USBDeviceEndPointCfg()
 120          * Description    : USBÉè±¸Ä£Ê½¶ËµãÅäÖÃ£¬Ä£Äâ¼æÈÝHIDÉè±¸£¬³ýÁË¶Ëµã0µÄ¿ØÖÆ´«Êä£¬»¹°üÀ¨¶Ëµã2ÅúÁ¿ÉÏÏÂ´«
 121          * Input          : None
 122          * Output         : None
 123          * Return         : None
 124          *******************************************************************************/
 125          void USBDeviceEndPointCfg() {
 126   1        UEP1_DMA = Ep1Buffer;                                                      //¶Ëµã1 ·¢ËÍÊý¾Ý´«ÊäµØÖ·
 127   1        UEP2_DMA = Ep2Buffer;                                                      //¶Ëµã2 INÊý¾Ý´«ÊäµØÖ·
 128   1        UEP2_3_MOD = 0xCC;                                                         //¶Ëµã2/3 µ¥»º³åÊÕ·¢Ê¹ÄÜ
 129   1        UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;                 //¶Ëµã2×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬INÊ
             -ÂÎñ·µ»ØNAK£¬OUT·µ»ØACK
 130   1      
 131   1        UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 //¶Ëµã1×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬INÊ
             -ÂÎñ·µ»ØNAK
 132   1        UEP0_DMA = Ep0Buffer;                                                      //¶Ëµã0Êý¾Ý´«ÊäµØÖ·
 133   1        UEP4_1_MOD = 0X40;                                                         //¶Ëµã1ÉÏ´«»º³åÇø£»¶Ëµã0µ¥64×Ö
             -½ÚÊÕ·¢»º³åÇø
 134   1        UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 //ÊÖ¶¯·­×ª£¬OUTÊÂÎñ·µ»ØACK£¬IN
             -ÊÂÎñ·µ»ØNAK
 135   1      }
 136          /*******************************************************************************
 137          * Function Name  : Config_Uart1(UINT8 *cfg_uart)
 138          * Description    : ÅäÖÃ´®¿Ú1²ÎÊý
 139          * Input          : ´®¿ÚÅäÖÃ²ÎÊý ËÄÎ»²¨ÌØÂÊ¡¢Í£Ö¹Î»¡¢Ð£Ñé¡¢Êý¾ÝÎ»
 140          * Output         : None
 141          * Return         : None
 142          *******************************************************************************/
 143          void Config_Uart1(UINT8 *cfg_uart) {
 144   1        UINT32 uart1_buad = 0;
 145   1        *((UINT8 *)&uart1_buad) = cfg_uart[3];
 146   1        *((UINT8 *)&uart1_buad+1) = cfg_uart[2];
 147   1        *((UINT8 *)&uart1_buad+2) = cfg_uart[1];
 148   1        *((UINT8 *)&uart1_buad+3) = cfg_uart[0];
 149   1        IE_UART1 = 0;
 150   1        SBAUD1 = 0 - FREQ_SYS/16/uart1_buad;
 151   1        IE_UART1 = 1;
 152   1      }
 153          /*******************************************************************************
 154          * Function Name  : DeviceInterrupt()
 155          * Description    : CH559USBÖÐ¶Ï´¦Àíº¯Êý
 156          *******************************************************************************/
 157          void    DeviceInterrupt( void ) interrupt INT_NO_USB {                     //USBÖÐ¶Ï·þÎñ³ÌÐò,Ê¹ÓÃ¼Ä´æÆ÷×é1
 158   1        UINT16 len;
 159   1        if(UIF_TRANSFER) {                                                          //USB´«ÊäÍê³É±êÖ¾
 160   2          switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP)) {
 161   3          case UIS_TOKEN_IN | 1:                                                  //endpoint 1# ¶ËµãÖÐ¶ÏÉÏ´«
 162   3            UEP1_T_LEN = 0;
 163   3            UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 164   3            break;
 165   3          case UIS_TOKEN_IN | 2: {                                                //endpoint 2# ¶ËµãÅúÁ¿ÉÏ´«
 166   4            UEP2_T_LEN = 0;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 4   

 167   4            UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 168   4            UpPoint2_Busy = 0;                                                  //Çå³ýÃ¦±êÖ¾
 169   4          }
 170   3          break;
 171   3          case UIS_TOKEN_OUT | 2:                                                 //endpoint 3# ¶ËµãÅúÁ¿ÏÂ´«
 172   3            if ( U_TOG_OK ) {                                                   // ²»Í¬²½µÄÊý¾Ý°ü½«¶ªÆú
 173   4              USBByteCount = USB_RX_LEN;
 174   4              USBBufOutPoint = 0;                                             //È¡Êý¾ÝÖ¸Õë¸´Î»
 175   4              UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_NAK;       //ÊÕµ½Ò»°üÊý¾Ý¾ÍNAK£¬Ö÷º¯Êý´¦ÀíÍê£¬ÓÉÖ
             -÷º¯ÊýÐÞ¸ÄÏìÓ¦·½Ê½
 176   4            }
 177   3            break;
 178   3          case UIS_TOKEN_SETUP | 0:                                                //SETUPÊÂÎñ
 179   3            len = USB_RX_LEN;
 180   3            if(len == (sizeof(USB_SETUP_REQ))) {
 181   4              SetupLen = ((UINT16)UsbSetupBuf->wLengthH<<8) | (UsbSetupBuf->wLengthL);
 182   4              len = 0;                                                      // Ä¬ÈÏÎª³É¹¦²¢ÇÒÉÏ´«0³¤¶È
 183   4              SetupReq = UsbSetupBuf->bRequest;
 184   4              if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD ) { //·Ç±ê×¼ÇëÇó
 185   5                switch( SetupReq ) {
 186   6                case GET_LINE_CODING:   //0x21  currently configured
 187   6                  pDescr = LineCoding;
 188   6                  len = sizeof(LineCoding);
 189   6                  len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;  // ±¾´Î´«Êä³¤¶È
 190   6                  memcpy(Ep0Buffer,pDescr,len);
 191   6                  SetupLen -= len;
 192   6                  pDescr += len;
 193   6                  break;
 194   6                case SET_CONTROL_LINE_STATE:  //0x22  generates RS-232/V.24 style control signals
 195   6                  break;
 196   6                case SET_LINE_CODING:      //0x20  Configure
 197   6                  break;
 198   6                default:
 199   6                  len = 0xFF;                                            /*ÃüÁî²»Ö§³Ö*/
 200   6                  break;
 201   6                }
 202   5              } else {                                                         //±ê×¼ÇëÇó
 203   5                switch(SetupReq) {                                           //ÇëÇóÂë
 204   6                case USB_GET_DESCRIPTOR:
 205   6                  switch(UsbSetupBuf->wValueH) {
 206   7                  case 1:                                                       //Éè±¸ÃèÊö·û
 207   7                    pDescr = DevDesc;                                         //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµÄ»º³åÇø
 208   7                    len = sizeof(DevDesc);
 209   7                    break;
 210   7                  case 2:                                                        //ÅäÖÃÃèÊö·û
 211   7                    pDescr = CfgDesc;                                          //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµÄ»º³åÇø
 212   7                    len = sizeof(CfgDesc);
 213   7                    break;
 214   7                  case 3:
 215   7                    if(UsbSetupBuf->wValueL == 0) {
 216   8                      pDescr = LangDes;
 217   8                      len = sizeof(LangDes);
 218   8                    } else if(UsbSetupBuf->wValueL == 1) {
 219   8                      pDescr = Manuf_Des;
 220   8                      len = sizeof(Manuf_Des);
 221   8                    } else if(UsbSetupBuf->wValueL == 2) {
 222   8                      pDescr = Prod_Des;
 223   8                      len = sizeof(Prod_Des);
 224   8                    } else {
 225   8                      pDescr = SerDes;
 226   8                      len = sizeof(SerDes);
 227   8                    }
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 5   

 228   7                    break;
 229   7                  default:
 230   7                    len = 0xff;                                                //²»Ö§³ÖµÄÃüÁî»òÕß³ö´í
 231   7                    break;
 232   7                  }
 233   6                  if ( SetupLen > len ) {
 234   7                    SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 235   7                  }
 236   6                  len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;                            //±
             -¾´Î´«Êä³¤¶È
 237   6                  memcpy(Ep0Buffer,pDescr,len);                                  //¼ÓÔØÉÏ´«Êý¾Ý
 238   6                  SetupLen -= len;
 239   6                  pDescr += len;
 240   6                  break;
 241   6                case USB_SET_ADDRESS:
 242   6                  SetupLen = UsbSetupBuf->wValueL;                              //ÔÝ´æUSBÉè±¸µØÖ·
 243   6                  break;
 244   6                case USB_GET_CONFIGURATION:
 245   6                  Ep0Buffer[0] = UsbConfig;
 246   6                  if ( SetupLen >= 1 ) {
 247   7                    len = 1;
 248   7                  }
 249   6                  break;
 250   6                case USB_SET_CONFIGURATION:
 251   6                  UsbConfig = UsbSetupBuf->wValueL;
 252   6                  break;
 253   6                case USB_GET_INTERFACE:
 254   6                  break;
 255   6                case USB_CLEAR_FEATURE:                                            //Clear Feature
 256   6                  if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_DEVICE ) {                /* Çå³ýÉè±¸ */
 257   7                    if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01 ) {
 258   8                      if( CfgDesc[ 7 ] & 0x20 ) {
 259   9                        /* »½ÐÑ */
 260   9                      } else {
 261   9                        len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 262   9                      }
 263   8                    } else {
 264   8                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 265   8                    }
 266   7                  } else if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP ) { // ¶Ëµã
 267   7                    switch( UsbSetupBuf->wIndexL ) {
 268   8                    case 0x83:
 269   8                      UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 270   8                      break;
 271   8                    case 0x03:
 272   8                      UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 273   8                      break;
 274   8                    case 0x82:
 275   8                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 276   8                      break;
 277   8                    case 0x02:
 278   8                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 279   8                      break;
 280   8                    case 0x81:
 281   8                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 282   8                      break;
 283   8                    case 0x01:
 284   8                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 285   8                      break;
 286   8                    default:
 287   8                      len = 0xFF;                                         // ²»Ö§³ÖµÄ¶Ëµã
 288   8                      break;
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 6   

 289   8                    }
 290   7                  } else {
 291   7                    len = 0xFF;                                                // ²»ÊÇ¶Ëµã²»Ö§³Ö
 292   7                  }
 293   6                  break;
 294   6                case USB_SET_FEATURE:                                          /* Set Feature */
 295   6                  if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_DEVICE ) {                /* ÉèÖÃÉè±¸ */
 296   7                    if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01 ) {
 297   8                      if( CfgDesc[ 7 ] & 0x20 ) {
 298   9                        /* ÐÝÃß */
 299   9      #ifdef DE_PRINTF
 300   9                        printf( "suspend\n" );                                                             //Ë¯Ãß×´Ì¬
 301   9      #endif
 302   9                        while ( XBUS_AUX & bUART0_TX ) {
 303  10                          ;    //µÈ´ý·¢ËÍÍê³É
 304  10                        }
 305   9                        SAFE_MOD = 0x55;
 306   9                        SAFE_MOD = 0xAA;
 307   9                        WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO;                      //USB»òÕßRXD0/1ÓÐÐÅºÅ
             -Ê±¿É±»»½ÐÑ
 308   9                        PCON |= PD;                                                                 //Ë¯Ãß
 309   9                        SAFE_MOD = 0x55;
 310   9                        SAFE_MOD = 0xAA;
 311   9                        WAKE_CTRL = 0x00;
 312   9                      } else {
 313   9                        len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 314   9                      }
 315   8                    } else {
 316   8                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 317   8                    }
 318   7                  } else if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_ENDP ) {         /* ÉèÖÃ¶Ëµã */
 319   7                    if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00 ) {
 320   8                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL ) {
 321   9                      case 0x83:
 322   9                        UEP3_CTRL = UEP3_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã3 IN STALL */
 323   9                        break;
 324   9                      case 0x03:
 325   9                        UEP3_CTRL = UEP3_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã3 OUT Stall */
 326   9                        break;
 327   9                      case 0x82:
 328   9                        UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã2 IN STALL */
 329   9                        break;
 330   9                      case 0x02:
 331   9                        UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã2 OUT Stall */
 332   9                        break;
 333   9                      case 0x81:
 334   9                        UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã1 IN STALL */
 335   9                        break;
 336   9                      case 0x01:
 337   9                        UEP1_CTRL = UEP1_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã1 OUT Stall */
 338   9                      default:
 339   9                        len = 0xFF;                                    /* ²Ù×÷Ê§°Ü */
 340   9                        break;
 341   9                      }
 342   8                    } else {
 343   8                      len = 0xFF;                                      /* ²Ù×÷Ê§°Ü */
 344   8                    }
 345   7                  } else {
 346   7                    len = 0xFF;                                          /* ²Ù×÷Ê§°Ü */
 347   7                  }
 348   6                  break;
 349   6                case USB_GET_STATUS:
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 7   

 350   6                  Ep0Buffer[0] = 0x00;
 351   6                  Ep0Buffer[1] = 0x00;
 352   6                  if ( SetupLen >= 2 ) {
 353   7                    len = 2;
 354   7                  } else {
 355   7                    len = SetupLen;
 356   7                  }
 357   6                  break;
 358   6                default:
 359   6                  len = 0xff;                                                    //²Ù×÷Ê§°Ü
 360   6                  break;
 361   6                }
 362   5              }
 363   4            } else {
 364   4              len = 0xff;                                                         //°ü³¤¶È´íÎó
 365   4            }
 366   3            if(len == 0xff) {
 367   4              SetupReq = 0xFF;
 368   4              UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 369   4            } else if(len <= DEFAULT_ENDP0_SIZE) {                                                   //ÉÏ´«Êý¾Ý»òÕß
             -×´Ì¬½×¶Î·µ»Ø0³¤¶È°ü
 370   4              UEP0_T_LEN = len;
 371   4              UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1£¬·µ»ØÓ¦´ðACK
 372   4            } else {
 373   4              UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 374   4              UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1,·µ»ØÓ¦´ðACK
 375   4            }
 376   3            break;
 377   3          case UIS_TOKEN_IN | 0:                                                      //endpoint0 IN
 378   3            switch(SetupReq) {
 379   4            case USB_GET_DESCRIPTOR:
 380   4              len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;                                 
             -//±¾´Î´«Êä³¤¶È
 381   4              memcpy( Ep0Buffer, pDescr, len );                                   //¼ÓÔØÉÏ´«Êý¾Ý
 382   4              SetupLen -= len;
 383   4              pDescr += len;
 384   4              UEP0_T_LEN = len;
 385   4              UEP0_CTRL ^= bUEP_T_TOG;                                             //Í¬²½±êÖ¾Î»·­×ª
 386   4              break;
 387   4            case USB_SET_ADDRESS:
 388   4              USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 389   4              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 390   4              break;
 391   4            default:
 392   4              UEP0_T_LEN = 0;                                                      //×´Ì¬½×¶ÎÍê³ÉÖÐ¶Ï»òÕßÊÇÇ¿ÖÆÉÏ´«0
             -³¤¶ÈÊý¾Ý°ü½áÊø¿ØÖÆ´«Êä
 393   4              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 394   4              break;
 395   4            }
 396   3            break;
 397   3          case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 398   3            if(SetupReq ==SET_LINE_CODING) { //ÉèÖÃ´®¿ÚÊôÐÔ
 399   4              if( U_TOG_OK ) {
 400   5                memcpy(LineCoding,UsbSetupBuf,USB_RX_LEN);
 401   5                Config_Uart1(LineCoding);
 402   5                UEP0_T_LEN = 0;
 403   5                UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_ACK;  // ×¼±¸ÉÏ´«0°ü
 404   5              }
 405   4            } else {
 406   4              UEP0_T_LEN = 0;
 407   4              UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_NAK;  //×´Ì¬½×¶Î£¬¶ÔINÏìÓ¦NAK
 408   4            }
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 8   

 409   3            break;
 410   3      
 411   3      
 412   3      
 413   3          default:
 414   3            break;
 415   3          }
 416   2          UIF_TRANSFER = 0;                                                           //Ð´0Çå¿ÕÖÐ¶Ï
 417   2        }
 418   1        if(UIF_BUS_RST) {                                                               //Éè±¸Ä£Ê½USB×ÜÏß¸´Î»ÖÐ¶Ï
 419   2      #ifdef DE_PRINTF
 420   2          printf( "reset\n" );                                                             //Ë¯Ãß×´Ì¬
 421   2      #endif
 422   2          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 423   2          UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;
 424   2          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;
 425   2          USB_DEV_AD = 0x00;
 426   2          UIF_SUSPEND = 0;
 427   2          UIF_TRANSFER = 0;
 428   2          UIF_BUS_RST = 0;                                                             //ÇåÖÐ¶Ï±êÖ¾
 429   2          Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÊäÈëÖ¸Õë
 430   2          Uart_Output_Point = 0;  //Ñ­»·»º³åÇø¶Á³öÖ¸Õë
 431   2          UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 432   2          USBByteCount = 0;       //USB¶ËµãÊÕµ½µÄ³¤¶È
 433   2          UsbConfig = 0;          //Çå³ýÅäÖÃÖµ
 434   2          UpPoint2_Busy = 0;
 435   2        }
 436   1        if (UIF_SUSPEND) {                                                               //USB×ÜÏß¹ÒÆð/»½ÐÑÍê³É
 437   2          UIF_SUSPEND = 0;
 438   2          if ( USB_MIS_ST & bUMS_SUSPEND ) {                                           //¹ÒÆð
 439   3      #ifdef DE_PRINTF
 440   3            printf( "suspend\n" );                                                             //Ë¯Ãß×´Ì¬
 441   3      #endif
 442   3            while ( XBUS_AUX & bUART0_TX ) {
 443   4              ;    //µÈ´ý·¢ËÍÍê³É
 444   4            }
 445   3            SAFE_MOD = 0x55;
 446   3            SAFE_MOD = 0xAA;
 447   3            WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO;                      //USB»òÕßRXD0/1ÓÐÐÅºÅÊ±¿É±»
             -»½ÐÑ
 448   3            PCON |= PD;                                                                 //Ë¯Ãß
 449   3            SAFE_MOD = 0x55;
 450   3            SAFE_MOD = 0xAA;
 451   3            WAKE_CTRL = 0x00;
 452   3          }
 453   2        } else {                                                                           //ÒâÍâµÄÖÐ¶Ï,²»¿ÉÄÜ·¢É
             -úµÄÇé¿ö
 454   2          USB_INT_FG = 0xFF;                                                             //ÇåÖÐ¶Ï±êÖ¾
 455   2      
 456   2        }
 457   1      }
 458          /*******************************************************************************
 459          * Function Name  : Uart1_ISR()
 460          * Description    : ´®¿Ú½ÓÊÕÖÐ¶Ïº¯Êý£¬ÊµÏÖÑ­»·»º³å½ÓÊÕ
 461          *******************************************************************************/
 462          void Uart1_ISR(void) interrupt INT_NO_UART1 {
 463   1        if(U1RI) { //ÊÕµ½Êý¾Ý
 464   2          Receive_Uart_Buf[Uart_Input_Point++] = SBUF1;
 465   2          UartByteCount++;                    //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 466   2          if(Uart_Input_Point>=UART_REV_LEN)
 467   2            Uart_Input_Point = 0;           //Ð´ÈëÖ¸Õë
 468   2          U1RI =0;
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 9   

 469   2        }
 470   1      
 471   1      }
 472          
 473          
 474          #pragma  NOAREGS
 475          
 476          // relay P3.3
 477          sbit LED0 = P3^3;
 478          
 479          //Ö÷º¯Êý
 480          main() {
 481   1        UINT8 lenth;
 482   1        UINT8 Uart_Timeout = 0;
 483   1        CfgFsys( );                                                           //CH559Ê±ÖÓÑ¡ÔñÅäÖÃ
 484   1        mDelaymS(5);                                                          //ÐÞ¸ÄÖ÷ÆµµÈ´ýÄÚ²¿¾§ÕñÎÈ¶¨,±Ø¼Ó
 485   1        mInitSTDIO( );                                                        //´®¿Ú0,¿ÉÒÔÓÃÓÚµ÷ÊÔ
 486   1        UART1Setup( );                                                        //ÓÃÓÚCDC
 487   1      
 488   1        Port3Cfg(1, 3);                                                             //P33
 489   1        LED0 = 0;
 490   1      
 491   1      #ifdef DE_PRINTF
 492   1        printf("start ...\n");
 493   1      #endif
 494   1        USBDeviceCfg();
 495   1        USBDeviceEndPointCfg();                                               //¶ËµãÅäÖÃ
 496   1        USBDeviceIntCfg();                                                    //ÖÐ¶Ï³õÊ¼»¯
 497   1        UEP0_T_LEN = 0;
 498   1        UEP1_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 499   1        UEP2_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 500   1      
 501   1        while(1) {
 502   2          if(UsbConfig) {
 503   3            if(USBByteCount) { //USB½ÓÊÕ¶ËµãÓÐÊý¾Ý
 504   4              
 505   4              if (Ep2Buffer[0] == 'A') {
 506   5                LED0 = ~LED0;
 507   5                printf("DEBUG: USB_OUT/serial: A\n ");
 508   5              }
 509   4      
 510   4              CH554UART1SendByte(Ep2Buffer[USBBufOutPoint++]);
 511   4              USBByteCount--;
 512   4              if(USBByteCount==0)
 513   4                UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_ACK;
 514   4            }
 515   3            
 516   3            if(UartByteCount)
 517   3              Uart_Timeout++;
 518   3            if(!UpPoint2_Busy) { //¶Ëµã²»·±Ã¦£¨¿ÕÏÐºóµÄµÚÒ»°üÊý¾Ý£¬Ö»ÓÃ×÷´¥·¢ÉÏ´«£©
 519   4              lenth = UartByteCount;
 520   4              if(lenth>0) {
 521   5                if(lenth>39 || Uart_Timeout>100) {
 522   6                  Uart_Timeout = 0;
 523   6                  if(Uart_Output_Point+lenth>UART_REV_LEN)
 524   6                    lenth = UART_REV_LEN-Uart_Output_Point;
 525   6                  UartByteCount -= lenth;
 526   6                  //Ð´ÉÏ´«¶Ëµã
 527   6                  memcpy(Ep2Buffer+MAX_PACKET_SIZE,&Receive_Uart_Buf[Uart_Output_Point],lenth);
 528   6                  Uart_Output_Point+=lenth;
 529   6                  if(Uart_Output_Point>=UART_REV_LEN)
 530   6                    Uart_Output_Point = 0;
C51 COMPILER V9.56.0.0   CDC                                                               04/29/2020 11:17:25 PAGE 10  

 531   6                  UEP2_T_LEN = lenth;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 532   6                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;            //Ó¦´ðACK
 533   6                  UpPoint2_Busy = 1;
 534   6                }
 535   5              }
 536   4            }
 537   3          }
 538   2        }
 539   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1853    ----
   CONSTANT SIZE    =    193    ----
   XDATA SIZE       =     23       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     70    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
